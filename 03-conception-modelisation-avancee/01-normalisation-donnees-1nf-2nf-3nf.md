üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.1 Normalisation des donn√©es (1NF, 2NF, 3NF)

## Introduction - L'art d'organiser les donn√©es

La normalisation est comme **ranger efficacement une biblioth√®que** : au lieu d'empiler tous les livres n'importe comment, vous les organisez logiquement pour √©viter les doublons, faciliter les recherches et maintenir l'ordre √† long terme.

> **Analogie simple** : Imaginez votre collection de musique. Plut√¥t que de dupliquer les informations de l'artiste dans chaque chanson, vous cr√©ez une liste d'artistes s√©par√©e et vous y faites r√©f√©rence. C'est exactement l'esprit de la normalisation !

**Les 3 formes normales essentielles :**
- **1NF (Premi√®re Forme Normale)** ‚Üí √âliminer les valeurs multiples
- **2NF (Deuxi√®me Forme Normale)** ‚Üí √âliminer les d√©pendances partielles
- **3NF (Troisi√®me Forme Normale)** ‚Üí √âliminer les d√©pendances transitives

## Pourquoi normaliser ? Les probl√®mes de la d√©normalisation

### üö® Exemple concret : Base d'√©cole mal con√ßue

Commen√ßons par voir ce qui se passe **sans normalisation** :

```sql
-- ‚ùå Table d√©normalis√©e - TOUS les probl√®mes r√©unis !
CREATE TABLE etudiants_cours_mauvais (
    id INTEGER PRIMARY KEY,
    nom_etudiant TEXT,
    email_etudiant TEXT,
    telephone_etudiant TEXT,
    classe TEXT,

    -- Informations du cours
    nom_cours TEXT,
    code_cours TEXT,
    credits_cours INTEGER,

    -- Informations du professeur
    nom_professeur TEXT,
    email_professeur TEXT,
    departement_professeur TEXT,

    -- Note
    note REAL,
    date_examen TEXT
);

-- Insertion de donn√©es... et c'est le cauchemar !
INSERT INTO etudiants_cours_mauvais VALUES
    (1, 'Alice Martin', 'alice@email.com', '0123456789', 'L3 Info',
     'Base de donn√©es', 'BDD101', 6,
     'Dr. Dupont', 'dupont@prof.com', 'Informatique',
     15.5, '2024-06-15'),
    (2, 'Alice Martin', 'alice@email.com', '0123456789', 'L3 Info',
     'Programmation', 'PROG201', 8,
     'Dr. Martin', 'martin@prof.com', 'Informatique',
     17.0, '2024-06-20'),
    (3, 'Bob Leroy', 'bob@email.com', '0987654321', 'L2 Info',
     'Base de donn√©es', 'BDD101', 6,
     'Dr. Dupont', 'dupont@prof.com', 'Informatique',
     12.5, '2024-06-15');
```

### üî• Les probl√®mes qui apparaissent imm√©diatement

```sql
-- Voir les horreurs de cette conception
SELECT * FROM etudiants_cours_mauvais;
```

**Probl√®mes identifi√©s :**

1. **Redondance massive** :
   - Alice appara√Æt 2 fois avec toutes ses infos
   - Dr. Dupont r√©p√©t√© pour chaque √©tudiant de son cours

2. **Incoh√©rences potentielles** :
   - Et si on tape mal l'email d'Alice dans une ligne ?
   - Et si on change le d√©partement du Dr. Dupont dans une seule ligne ?

3. **Anomalies de mise √† jour** :
   - Changer l'email d'Alice = modifier plusieurs lignes
   - Risque d'oublier certaines lignes

4. **Anomalies d'insertion** :
   - Impossible d'ajouter un nouveau cours sans √©tudiant
   - Impossible d'ajouter un √©tudiant sans cours

5. **Anomalies de suppression** :
   - Supprimer le dernier √©tudiant d'un cours = perdre les infos du cours
   - Supprimer un √©tudiant = perdre potentiellement des infos prof

## Premi√®re Forme Normale (1NF) - Atomicit√© des donn√©es

### üéØ R√®gle 1NF : Une valeur par cellule

**Principe** : Chaque cellule doit contenir une **valeur atomique** (indivisible), pas une liste ou un ensemble de valeurs.

### ‚ùå Violations typiques de 1NF

```sql
-- Table violant la 1NF
CREATE TABLE etudiants_mauvais_1nf (
    id INTEGER PRIMARY KEY,
    nom TEXT,
    telephones TEXT,           -- ‚ùå Plusieurs t√©l√©phones s√©par√©s par ';'
    matieres_suivies TEXT,     -- ‚ùå Liste de mati√®res
    notes TEXT,                -- ‚ùå Notes correspondantes
    langues TEXT               -- ‚ùå Langues parl√©es
);

INSERT INTO etudiants_mauvais_1nf VALUES
    (1, 'Alice Martin', '0123456789;0987654321',
     'Maths;Physique;Chimie', '15;17;14', 'Fran√ßais;Anglais;Espagnol'),
    (2, 'Bob Leroy', '0555666777',
     'Informatique;Maths', '16;18', 'Fran√ßais;Anglais');

-- Cauchemar pour les requ√™tes !
SELECT * FROM etudiants_mauvais_1nf;

-- Comment trouver tous les √©tudiants qui suivent "Maths" ?
-- Comment calculer la moyenne en Maths ?
-- Comment g√©rer l'ajout d'une nouvelle mati√®re ?
```

### ‚úÖ Solution 1NF : D√©composition atomique

```sql
-- √âtape 1 : S√©parer les informations de base
CREATE TABLE etudiants_1nf (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE
);

-- √âtape 2 : Tables s√©par√©es pour les valeurs multiples
CREATE TABLE telephones_etudiants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    etudiant_id INTEGER,
    telephone TEXT,
    type_telephone TEXT, -- 'mobile', 'fixe', 'urgence'
    FOREIGN KEY (etudiant_id) REFERENCES etudiants_1nf(id)
);

CREATE TABLE langues_etudiants (
    etudiant_id INTEGER,
    langue TEXT,
    niveau TEXT, -- 'd√©butant', 'interm√©diaire', 'courant', 'natif'
    PRIMARY KEY (etudiant_id, langue),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants_1nf(id)
);

-- Donn√©es en 1NF
INSERT INTO etudiants_1nf (nom, email) VALUES
    ('Alice Martin', 'alice@email.com'),
    ('Bob Leroy', 'bob@email.com');

INSERT INTO telephones_etudiants (etudiant_id, telephone, type_telephone) VALUES
    (1, '0123456789', 'mobile'),
    (1, '0987654321', 'fixe'),
    (2, '0555666777', 'mobile');

INSERT INTO langues_etudiants VALUES
    (1, 'Fran√ßais', 'natif'),
    (1, 'Anglais', 'courant'),
    (1, 'Espagnol', 'interm√©diaire'),
    (2, 'Fran√ßais', 'natif'),
    (2, 'Anglais', 'courant');

-- Maintenant les requ√™tes sont possibles !
SELECT e.nom, t.telephone, t.type_telephone
FROM etudiants_1nf e
JOIN telephones_etudiants t ON e.id = t.etudiant_id
WHERE e.nom = 'Alice Martin';
```

### üîç V√©rification 1NF

```sql
-- Test : Tous les √©tudiants parlant anglais
SELECT DISTINCT e.nom
FROM etudiants_1nf e
JOIN langues_etudiants l ON e.id = l.etudiant_id
WHERE l.langue = 'Anglais';

-- Test : Statistiques des langues
SELECT
    langue,
    COUNT(*) as nb_etudiants,
    COUNT(CASE WHEN niveau = 'courant' THEN 1 END) as niveau_courant
FROM langues_etudiants
GROUP BY langue
ORDER BY nb_etudiants DESC;
```

## Deuxi√®me Forme Normale (2NF) - √âlimination des d√©pendances partielles

### üéØ R√®gle 2NF : D√©pendance fonctionnelle compl√®te

**Principe** : √ätre en 1NF ET chaque attribut non-cl√© doit d√©pendre de **toute la cl√© primaire**, pas seulement d'une partie.

‚ö†Ô∏è **Ne concerne que les cl√©s compos√©es** (plusieurs colonnes dans la cl√© primaire)

### ‚ùå Violation de 2NF : D√©pendances partielles

```sql
-- Table violant la 2NF
CREATE TABLE inscriptions_notes_mauvais_2nf (
    etudiant_id INTEGER,
    cours_id INTEGER,

    -- D√©pendent de toute la cl√© (etudiant_id + cours_id)
    note REAL,
    date_examen TEXT,

    -- ‚ùå D√©pendent seulement de etudiant_id (d√©pendance partielle)
    nom_etudiant TEXT,
    email_etudiant TEXT,
    classe_etudiant TEXT,

    -- ‚ùå D√©pendent seulement de cours_id (d√©pendance partielle)
    nom_cours TEXT,
    credits_cours INTEGER,
    nom_professeur TEXT,

    PRIMARY KEY (etudiant_id, cours_id)
);

INSERT INTO inscriptions_notes_mauvais_2nf VALUES
    (1, 101, 15.5, '2024-06-15', 'Alice Martin', 'alice@email.com', 'L3 Info',
     'Base de donn√©es', 6, 'Dr. Dupont'),
    (1, 102, 17.0, '2024-06-20', 'Alice Martin', 'alice@email.com', 'L3 Info',
     'Programmation', 8, 'Dr. Martin'),
    (2, 101, 12.5, '2024-06-15', 'Bob Leroy', 'bob@email.com', 'L2 Info',
     'Base de donn√©es', 6, 'Dr. Dupont');

-- Probl√®mes de la violation 2NF
SELECT * FROM inscriptions_notes_mauvais_2nf;
```

**Probl√®mes identifi√©s :**
- **Redondance** : Infos d'Alice r√©p√©t√©es pour chaque cours
- **Anomalies de mise √† jour** : Changer l'email d'Alice = modifier plusieurs lignes
- **Incoh√©rences** : Risk d'avoir des informations diff√©rentes pour le m√™me √©tudiant

### ‚úÖ Solution 2NF : S√©paration par d√©pendances

```sql
-- S√©parer selon les d√©pendances fonctionnelles

-- Table 1 : Informations des √©tudiants (d√©pendent de etudiant_id)
CREATE TABLE etudiants_2nf (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    classe TEXT
);

-- Table 2 : Informations des cours (d√©pendent de cours_id)
CREATE TABLE cours_2nf (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    code TEXT UNIQUE,
    credits INTEGER,
    professeur TEXT
);

-- Table 3 : Inscriptions et notes (d√©pendent de etudiant_id + cours_id)
CREATE TABLE inscriptions_2nf (
    etudiant_id INTEGER,
    cours_id INTEGER,
    note REAL,
    date_examen TEXT,
    PRIMARY KEY (etudiant_id, cours_id),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants_2nf(id),
    FOREIGN KEY (cours_id) REFERENCES cours_2nf(id)
);

-- Insertion des donn√©es normalis√©es
INSERT INTO etudiants_2nf (nom, email, classe) VALUES
    ('Alice Martin', 'alice@email.com', 'L3 Info'),
    ('Bob Leroy', 'bob@email.com', 'L2 Info');

INSERT INTO cours_2nf (nom, code, credits, professeur) VALUES
    ('Base de donn√©es', 'BDD101', 6, 'Dr. Dupont'),
    ('Programmation', 'PROG201', 8, 'Dr. Martin');

INSERT INTO inscriptions_2nf VALUES
    (1, 1, 15.5, '2024-06-15'),
    (1, 2, 17.0, '2024-06-20'),
    (2, 1, 12.5, '2024-06-15');
```

### üîç V√©rification 2NF

```sql
-- Maintenant les mises √† jour sont simples et s√ªres
UPDATE etudiants_2nf SET email = 'alice.martin@nouveau.com' WHERE id = 1;

-- Une seule ligne modifi√©e, coh√©rence garantie !

-- Requ√™te compl√®te avec jointures
SELECT
    e.nom as etudiant,
    c.nom as cours,
    c.credits,
    i.note,
    i.date_examen
FROM inscriptions_2nf i
JOIN etudiants_2nf e ON i.etudiant_id = e.id
JOIN cours_2nf c ON i.cours_id = c.id
ORDER BY e.nom, c.nom;
```

## Troisi√®me Forme Normale (3NF) - √âlimination des d√©pendances transitives

### üéØ R√®gle 3NF : Pas de d√©pendance transitive

**Principe** : √ätre en 2NF ET aucun attribut non-cl√© ne doit d√©pendre d'un autre attribut non-cl√©.

**D√©pendance transitive** : A ‚Üí B ‚Üí C (donc A ‚Üí C indirectement)

### ‚ùå Violation de 3NF : D√©pendances transitives

```sql
-- Table violant la 3NF
CREATE TABLE cours_mauvais_3nf (
    id INTEGER PRIMARY KEY,
    nom TEXT,
    code TEXT,
    credits INTEGER,

    -- D√©pendance directe de l'id du cours
    professeur_nom TEXT,

    -- ‚ùå D√©pendance transitive : id ‚Üí professeur_nom ‚Üí departement
    professeur_departement TEXT,
    professeur_email TEXT,
    professeur_bureau TEXT
);

INSERT INTO cours_mauvais_3nf VALUES
    (1, 'Base de donn√©es', 'BDD101', 6, 'Dr. Dupont', 'Informatique', 'dupont@univ.fr', 'B204'),
    (2, 'Programmation', 'PROG201', 8, 'Dr. Martin', 'Informatique', 'martin@univ.fr', 'B205'),
    (3, 'R√©seaux', 'RES301', 5, 'Dr. Dupont', 'Informatique', 'dupont@univ.fr', 'B204'),
    (4, 'Math√©matiques', 'MATH101', 6, 'Dr. Bernard', 'Math√©matiques', 'bernard@univ.fr', 'A102');

-- Probl√®mes de la violation 3NF
SELECT * FROM cours_mauvais_3nf;
```

**Probl√®mes identifi√©s :**
- **Redondance** : Dr. Dupont r√©p√©t√© avec ses infos dans plusieurs cours
- **Anomalies de mise √† jour** : Changer le bureau du Dr. Dupont = modifier plusieurs lignes
- **Incoh√©rences** : Risque d'avoir des infos diff√©rentes pour le m√™me professeur

### ‚úÖ Solution 3NF : S√©paration des entit√©s ind√©pendantes

```sql
-- S√©parer les professeurs des cours

-- Table 1 : Professeurs (entit√© ind√©pendante)
CREATE TABLE professeurs_3nf (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    departement TEXT,
    bureau TEXT
);

-- Table 2 : Cours (r√©f√©rence aux professeurs)
CREATE TABLE cours_3nf (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    code TEXT UNIQUE,
    credits INTEGER,
    professeur_id INTEGER,
    FOREIGN KEY (professeur_id) REFERENCES professeurs_3nf(id)
);

-- Insertion des donn√©es normalis√©es
INSERT INTO professeurs_3nf (nom, email, departement, bureau) VALUES
    ('Dr. Dupont', 'dupont@univ.fr', 'Informatique', 'B204'),
    ('Dr. Martin', 'martin@univ.fr', 'Informatique', 'B205'),
    ('Dr. Bernard', 'bernard@univ.fr', 'Math√©matiques', 'A102');

INSERT INTO cours_3nf (nom, code, credits, professeur_id) VALUES
    ('Base de donn√©es', 'BDD101', 6, 1),
    ('Programmation', 'PROG201', 8, 2),
    ('R√©seaux', 'RES301', 5, 1),
    ('Math√©matiques', 'MATH101', 6, 3);
```

### üîç V√©rification 3NF

```sql
-- Mise √† jour simple et coh√©rente
UPDATE professeurs_3nf SET bureau = 'B210' WHERE nom = 'Dr. Dupont';

-- Tous les cours du Dr. Dupont refl√®tent automatiquement le changement !

-- Requ√™tes riches possibles
SELECT
    c.nom as cours,
    c.code,
    p.nom as professeur,
    p.departement,
    p.bureau
FROM cours_3nf c
JOIN professeurs_3nf p ON c.professeur_id = p.id
ORDER BY p.departement, c.nom;

-- Statistiques par d√©partement
SELECT
    p.departement,
    COUNT(c.id) as nb_cours,
    AVG(c.credits) as credits_moyen
FROM professeurs_3nf p
LEFT JOIN cours_3nf c ON p.id = c.professeur_id
GROUP BY p.departement;
```

## Exemple complet : De 0NF √† 3NF

### üéØ Transformation compl√®te d'une base d'√©cole

Voyons la transformation compl√®te depuis une table d√©normalis√©e vers un sch√©ma 3NF :

```sql
-- === POINT DE D√âPART : Table compl√®tement d√©normalis√©e ===
CREATE TABLE ecole_denormalisee (
    id INTEGER PRIMARY KEY,

    -- √âtudiant
    nom_etudiant TEXT,
    email_etudiant TEXT,
    telephones_etudiant TEXT,  -- ‚ùå Valeurs multiples

    -- Cours
    nom_cours TEXT,
    code_cours TEXT,
    credits_cours INTEGER,

    -- Professeur
    nom_professeur TEXT,
    email_professeur TEXT,
    departement TEXT,        -- ‚ùå D√©pendance transitive
    bureau TEXT,             -- ‚ùå D√©pendance transitive

    -- Note
    note REAL,
    date_examen TEXT
);
```

### üîÑ Transformation √©tape par √©tape

```sql
-- === √âTAPE 1 : Passage en 1NF ===
-- √âliminer les valeurs multiples

-- √âtudiants avec t√©l√©phones s√©par√©s
CREATE TABLE etudiants_temp (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE
);

CREATE TABLE telephones_temp (
    etudiant_id INTEGER,
    telephone TEXT,
    PRIMARY KEY (etudiant_id, telephone),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants_temp(id)
);

-- Table principale temporaire en 1NF
CREATE TABLE ecole_1nf (
    etudiant_id INTEGER,
    nom_etudiant TEXT,
    email_etudiant TEXT,
    nom_cours TEXT,
    code_cours TEXT,
    credits_cours INTEGER,
    nom_professeur TEXT,
    email_professeur TEXT,
    departement TEXT,
    bureau TEXT,
    note REAL,
    date_examen TEXT
);

-- === √âTAPE 2 : Passage en 2NF ===
-- Cr√©er une cl√© compos√©e et √©liminer les d√©pendances partielles

CREATE TABLE inscriptions_temp (
    etudiant_id INTEGER,
    cours_id INTEGER,
    note REAL,
    date_examen TEXT,
    PRIMARY KEY (etudiant_id, cours_id)
);

-- === √âTAPE 3 : Passage en 3NF ===
-- √âliminer les d√©pendances transitives (professeur ‚Üí d√©partement)
```

### ‚úÖ Sch√©ma final normalis√© 3NF

```sql
-- === SCH√âMA FINAL EN 3NF ===

-- D√©partements (nouvelle entit√© identifi√©e)
CREATE TABLE departements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL UNIQUE,
    batiment TEXT,
    responsable TEXT
);

-- Professeurs (sans d√©pendance transitive)
CREATE TABLE professeurs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    bureau TEXT,
    departement_id INTEGER,
    FOREIGN KEY (departement_id) REFERENCES departements(id)
);

-- √âtudiants
CREATE TABLE etudiants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    numero_etudiant TEXT UNIQUE
);

-- T√©l√©phones des √©tudiants
CREATE TABLE telephones_etudiants (
    etudiant_id INTEGER,
    telephone TEXT,
    type TEXT DEFAULT 'mobile',
    PRIMARY KEY (etudiant_id, telephone),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE
);

-- Cours
CREATE TABLE cours (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    code TEXT UNIQUE,
    credits INTEGER CHECK (credits > 0),
    professeur_id INTEGER,
    FOREIGN KEY (professeur_id) REFERENCES professeurs(id)
);

-- Inscriptions et notes
CREATE TABLE inscriptions (
    etudiant_id INTEGER,
    cours_id INTEGER,
    note REAL CHECK (note BETWEEN 0 AND 20),
    date_examen TEXT,
    semestre TEXT,
    PRIMARY KEY (etudiant_id, cours_id),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE,
    FOREIGN KEY (cours_id) REFERENCES cours(id) ON DELETE CASCADE
);

-- === DONN√âES D'EXEMPLE ===

INSERT INTO departements (nom, batiment, responsable) VALUES
    ('Informatique', 'B√¢timent B', 'Prof. Directeur'),
    ('Math√©matiques', 'B√¢timent A', 'Prof. Responsable');

INSERT INTO professeurs (nom, email, bureau, departement_id) VALUES
    ('Dr. Dupont', 'dupont@univ.fr', 'B204', 1),
    ('Dr. Martin', 'martin@univ.fr', 'B205', 1),
    ('Dr. Bernard', 'bernard@univ.fr', 'A102', 2);

INSERT INTO etudiants (nom, email, numero_etudiant) VALUES
    ('Alice Martin', 'alice@etu.fr', '20240001'),
    ('Bob Leroy', 'bob@etu.fr', '20240002'),
    ('Claire Dubois', 'claire@etu.fr', '20240003');

INSERT INTO telephones_etudiants VALUES
    (1, '0123456789', 'mobile'),
    (1, '0987654321', 'fixe'),
    (2, '0555666777', 'mobile');

INSERT INTO cours (nom, code, credits, professeur_id) VALUES
    ('Base de donn√©es', 'BDD101', 6, 1),
    ('Programmation', 'PROG201', 8, 2),
    ('R√©seaux', 'RES301', 5, 1),
    ('Math√©matiques', 'MATH101', 6, 3);

INSERT INTO inscriptions (etudiant_id, cours_id, note, date_examen, semestre) VALUES
    (1, 1, 15.5, '2024-06-15', 'S1'),
    (1, 2, 17.0, '2024-06-20', 'S1'),
    (2, 1, 12.5, '2024-06-15', 'S1'),
    (2, 3, 14.0, '2024-06-18', 'S1'),
    (3, 4, 18.5, '2024-06-22', 'S1');
```

## Avantages et b√©n√©fices de la normalisation

### üéØ D√©monstration des avantages

```sql
-- === AVANTAGES EN ACTION ===

-- 1. Coh√©rence garantie
UPDATE professeurs SET email = 'dupont.nouveau@univ.fr' WHERE id = 1;
-- Un seul UPDATE pour tous les cours du professeur !

-- 2. Pas de redondance
SELECT
    COUNT(*) as lignes_total,
    COUNT(DISTINCT p.nom) as professeurs_uniques,
    COUNT(DISTINCT e.nom) as etudiants_uniques
FROM inscriptions i
JOIN cours c ON i.cours_id = c.id
JOIN professeurs p ON c.professeur_id = p.id
JOIN etudiants e ON i.etudiant_id = e.id;

-- 3. Requ√™tes riches possibles
SELECT
    d.nom as departement,
    p.nom as professeur,
    COUNT(DISTINCT c.id) as nb_cours,
    COUNT(DISTINCT i.etudiant_id) as nb_etudiants,
    AVG(i.note) as moyenne_notes
FROM departements d
JOIN professeurs p ON d.id = p.departement_id
JOIN cours c ON p.id = c.professeur_id
JOIN inscriptions i ON c.id = i.cours_id
WHERE i.note IS NOT NULL
GROUP BY d.id, p.id
ORDER BY moyenne_notes DESC;

-- 4. Int√©grit√© r√©f√©rentielle
-- Impossible de supprimer un professeur qui a des cours
-- Impossible d'inscrire un √©tudiant √† un cours inexistant

-- 5. Maintenance facilit√©e
-- Ajouter un nouveau t√©l√©phone √† Alice
INSERT INTO telephones_etudiants VALUES (1, '0611223344', 'professionnel');

-- Changer le responsable d'un d√©partement
UPDATE departements SET responsable = 'Nouveau Responsable' WHERE nom = 'Informatique';
```

### üìä Comparaison avant/apr√®s normalisation

```sql
-- === M√âTRIQUES DE QUALIT√â ===

-- Avant normalisation (estimation pour notre exemple)
SELECT 'Avant normalisation' as etat,
       5 as nb_tables,
       25 as lignes_donnees,
       15 as redondances_estimees,
       8 as points_mise_a_jour_risque;

-- Apr√®s normalisation
SELECT 'Apr√®s normalisation' as etat,
       6 as nb_tables,
       17 as lignes_donnees,
       0 as redondances,
       0 as points_mise_a_jour_risque;

-- Statistiques r√©elles du sch√©ma normalis√©
SELECT
    'Professeurs' as table_name, COUNT(*) as nb_lignes FROM professeurs
UNION ALL SELECT '√âtudiants', COUNT(*) FROM etudiants
UNION ALL SELECT 'Cours', COUNT(*) FROM cours
UNION ALL SELECT 'Inscriptions', COUNT(*) FROM inscriptions
UNION ALL SELECT 'D√©partements', COUNT(*) FROM departements
UNION ALL SELECT 'T√©l√©phones', COUNT(*) FROM telephones_etudiants;
```

## Cas particuliers et exceptions

### üéØ Quand ne PAS normaliser ?

**D√©normalisation contr√¥l√©e** peut √™tre justifi√©e pour :

```sql
-- Exemple : Table de reporting d√©normalis√©e pour performance
CREATE TABLE rapport_notes_denormalise (
    id INTEGER PRIMARY KEY,
    etudiant_nom TEXT,
    cours_nom TEXT,
    professeur_nom TEXT,
    departement_nom TEXT,
    note REAL,
    date_examen TEXT,

    -- Colonnes calcul√©es d√©normalis√©es
    moyenne_etudiant REAL,
    moyenne_cours REAL,
    rang_dans_cours INTEGER,

    -- Mise √† jour via trigger ou batch
    derniere_maj TEXT DEFAULT (datetime('now'))
);

-- Trigger pour maintenir la coh√©rence
CREATE TRIGGER maj_rapport_notes
AFTER INSERT ON inscriptions
BEGIN
    -- Recalculer et ins√©rer/mettre √† jour le rapport
    INSERT OR REPLACE INTO rapport_notes_denormalise (...)
    SELECT ...; -- Requ√™te complexe avec toutes les jointures
END;
```

**Justifications pour la d√©normalisation :**
- **Performance** : √âviter des jointures complexes r√©p√©t√©es
- **Reporting** : Tables pr√©calcul√©es pour les tableaux de bord
- **Historique** : Snapshot des donn√©es √† un moment donn√©
- **Cache** : R√©sultats de calculs co√ªteux

### ‚ö†Ô∏è R√®gles pour la d√©normalisation contr√¥l√©e

```sql
-- 1. Garder la source normalis√©e
-- 2. Automatiser la synchronisation
-- 3. Documenter la justification
-- 4. Monitorer la coh√©rence

-- Exemple de v√©rification de coh√©rence
CREATE VIEW verification_coherence AS
SELECT
    'Incoh√©rences d√©tect√©es' as alerte,
    COUNT(*) as nb_problemes
FROM rapport_notes_denormalise r
JOIN inscriptions i ON r.etudiant_nom || r.cours_nom =
    (SELECT e.nom || c.nom FROM etudiants e, cours c
     WHERE e.id = i.etudiant_id AND c.id = i.cours_id)
WHERE r.note != i.note;
```

## R√©capitulatif et bonnes pratiques

### ‚úÖ Processus de normalisation

**√âtapes syst√©matiques :**
1. **Identifier les entit√©s** et leurs attributs
2. **Appliquer 1NF** : Atomicit√© des valeurs
3. **Appliquer 2NF** : √âliminer d√©pendances partielles
4. **Appliquer 3NF** : √âliminer d√©pendances transitives
5. **Valider** : Tester l'int√©grit√© et les performances
6. **Documenter** : Justifier les choix de conception

### üéØ Check-list de normalisation

#### ‚úÖ V√©rification 1NF
- [ ] Chaque cellule contient une valeur atomique
- [ ] Pas de listes ou valeurs s√©par√©es par des d√©limiteurs
- [ ] Pas de colonnes r√©p√©titives (col1, col2, col3...)
- [ ] Chaque ligne est unique (cl√© primaire d√©finie)

#### ‚úÖ V√©rification 2NF
- [ ] La table est en 1NF
- [ ] Identifier toutes les cl√©s compos√©es
- [ ] V√©rifier que chaque attribut d√©pend de TOUTE la cl√©
- [ ] S√©parer les attributs avec d√©pendances partielles

#### ‚úÖ V√©rification 3NF
- [ ] La table est en 2NF
- [ ] Identifier les d√©pendances transitives (A ‚Üí B ‚Üí C)
- [ ] Cr√©er des tables s√©par√©es pour les entit√©s ind√©pendantes
- [ ] Utiliser des cl√©s √©trang√®res pour maintenir les liens

### üìã Bonnes pratiques SQLite sp√©cifiques

```sql
-- ‚úÖ Nomenclature coh√©rente
CREATE TABLE etudiants (              -- Pluriel pour les tables
    id INTEGER PRIMARY KEY,           -- id simple pour PK
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    departement_id INTEGER,           -- _id pour les FK
    FOREIGN KEY (departement_id) REFERENCES departements(id)
);

-- ‚úÖ Contraintes appropri√©es
CREATE TABLE cours (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL CHECK (LENGTH(nom) > 0),
    code TEXT UNIQUE CHECK (LENGTH(code) BETWEEN 3 AND 10),
    credits INTEGER CHECK (credits BETWEEN 1 AND 12),
    professeur_id INTEGER NOT NULL,
    FOREIGN KEY (professeur_id) REFERENCES professeurs(id)
);

-- ‚úÖ Index sur les cl√©s √©trang√®res
CREATE INDEX idx_cours_professeur ON cours(professeur_id);
CREATE INDEX idx_inscriptions_etudiant ON inscriptions(etudiant_id);
CREATE INDEX idx_inscriptions_cours ON inscriptions(cours_id);
```

### üîß Outils d'analyse et validation

```sql
-- === REQU√äTES DE VALIDATION DE LA NORMALISATION ===

-- 1. D√©tecter les violations potentielles de 1NF
SELECT 'V√©rification 1NF' as test;

-- Chercher des valeurs avec s√©parateurs suspects
SELECT 'Valeurs avec s√©parateurs' as probleme, COUNT(*) as occurrences
FROM etudiants
WHERE nom LIKE '%,%' OR nom LIKE '%;%' OR nom LIKE '%|%';

-- Chercher des emails multiples
SELECT 'Emails multiples possibles' as probleme, COUNT(*) as occurrences
FROM etudiants
WHERE email LIKE '%,%' OR email LIKE '%;%';

-- 2. V√©rifier l'int√©grit√© r√©f√©rentielle (2NF/3NF)
SELECT 'V√©rification int√©grit√© r√©f√©rentielle' as test;

-- Cours sans professeur valide
SELECT 'Cours sans professeur' as probleme, COUNT(*) as occurrences
FROM cours c
LEFT JOIN professeurs p ON c.professeur_id = p.id
WHERE p.id IS NULL;

-- Inscriptions avec √©tudiants inexistants
SELECT 'Inscriptions orphelines (√©tudiants)' as probleme, COUNT(*) as occurrences
FROM inscriptions i
LEFT JOIN etudiants e ON i.etudiant_id = e.id
WHERE e.id IS NULL;

-- Inscriptions avec cours inexistants
SELECT 'Inscriptions orphelines (cours)' as probleme, COUNT(*) as occurrences
FROM inscriptions i
LEFT JOIN cours c ON i.cours_id = c.id
WHERE c.id IS NULL;

-- 3. Analyser la redondance restante
SELECT 'Analyse de redondance' as test;

-- V√©rifier l'unicit√© des entit√©s principales
SELECT
    'Doublons potentiels √©tudiants' as probleme,
    COUNT(*) - COUNT(DISTINCT LOWER(nom) || LOWER(email)) as occurrences
FROM etudiants;

SELECT
    'Doublons potentiels cours' as probleme,
    COUNT(*) - COUNT(DISTINCT UPPER(code)) as occurrences
FROM cours;

-- 4. Statistiques de qualit√©
SELECT 'M√©triques de qualit√©' as test;

SELECT
    'Tables normalis√©es' as metrique,
    (SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%') as valeur;

SELECT
    'Contraintes FK' as metrique,
    COUNT(*) as valeur
FROM pragma_foreign_key_list('cours')
UNION ALL SELECT 'Contraintes FK', COUNT(*) FROM pragma_foreign_key_list('inscriptions')
UNION ALL SELECT 'Contraintes FK', COUNT(*) FROM pragma_foreign_key_list('telephones_etudiants');
```

### üéØ Patterns de normalisation avanc√©s

#### Pattern 1 : Entit√©s faibles

```sql
-- Entit√© faible : d√©pend d'une autre entit√© pour son existence
CREATE TABLE adresses_etudiants (
    etudiant_id INTEGER,
    type_adresse TEXT,  -- 'domicile', 'famille', 'temporaire'
    rue TEXT,
    ville TEXT,
    code_postal TEXT,
    pays TEXT DEFAULT 'France',
    PRIMARY KEY (etudiant_id, type_adresse),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants(id) ON DELETE CASCADE
);

-- Si l'√©tudiant est supprim√©, ses adresses le sont aussi
```

#### Pattern 2 : Attributs multi-valu√©s normalis√©s

```sql
-- Au lieu de : competences TEXT (contenant 'Java;Python;SQL')
CREATE TABLE competences (
    id INTEGER PRIMARY KEY,
    nom TEXT UNIQUE NOT NULL,
    domaine TEXT  -- 'programmation', 'base_de_donnees', 'web'
);

CREATE TABLE etudiants_competences (
    etudiant_id INTEGER,
    competence_id INTEGER,
    niveau TEXT CHECK (niveau IN ('d√©butant', 'interm√©diaire', 'avanc√©', 'expert')),
    date_acquisition TEXT,
    certifie INTEGER DEFAULT 0,
    PRIMARY KEY (etudiant_id, competence_id),
    FOREIGN KEY (etudiant_id) REFERENCES etudiants(id),
    FOREIGN KEY (competence_id) REFERENCES competences(id)
);

-- Donn√©es d'exemple
INSERT INTO competences (nom, domaine) VALUES
    ('Python', 'programmation'),
    ('SQL', 'base_de_donnees'),
    ('JavaScript', 'programmation'),
    ('SQLite', 'base_de_donnees');

INSERT INTO etudiants_competences VALUES
    (1, 1, 'avanc√©', '2023-09-15', 1),
    (1, 2, 'interm√©diaire', '2024-01-10', 0),
    (2, 3, 'd√©butant', '2024-02-01', 0);
```

#### Pattern 3 : Hi√©rarchies et auto-r√©f√©rences

```sql
-- Hi√©rarchie de mati√®res (mati√®re ‚Üí sous-mati√®res)
CREATE TABLE matieres (
    id INTEGER PRIMARY KEY,
    nom TEXT NOT NULL,
    code TEXT UNIQUE,
    description TEXT,
    matiere_parent_id INTEGER,  -- Auto-r√©f√©rence
    niveau INTEGER DEFAULT 1,   -- 1=principale, 2=sous-mati√®re, etc.
    FOREIGN KEY (matiere_parent_id) REFERENCES matieres(id)
);

INSERT INTO matieres (nom, code, matiere_parent_id, niveau) VALUES
    ('Informatique', 'INFO', NULL, 1),
    ('Programmation', 'PROG', 1, 2),
    ('Base de donn√©es', 'BDD', 1, 2),
    ('Python', 'PY', 2, 3),
    ('Java', 'JAVA', 2, 3),
    ('SQL', 'SQL', 3, 3),
    ('NoSQL', 'NOSQL', 3, 3);

-- Requ√™te r√©cursive pour afficher la hi√©rarchie
WITH RECURSIVE hierarchie_matieres(id, nom, niveau, chemin) AS (
    -- Niveau racine
    SELECT id, nom, niveau, nom as chemin
    FROM matieres
    WHERE matiere_parent_id IS NULL

    UNION ALL

    -- Niveaux suivants
    SELECT m.id, m.nom, m.niveau, h.chemin || ' > ' || m.nom
    FROM matieres m
    JOIN hierarchie_matieres h ON m.matiere_parent_id = h.id
)
SELECT niveau, chemin, nom FROM hierarchie_matieres ORDER BY chemin;
```

## Exercice pratique complet - Normalisation d'un syst√®me de biblioth√®que

### üéØ Objectif : Normaliser une base de biblioth√®que

**Situation initiale : Table compl√®tement d√©normalis√©e**

```sql
-- === POINT DE D√âPART : CAUCHEMAR DE NORMALISATION ===
CREATE TABLE bibliotheque_denormalisee (
    id INTEGER PRIMARY KEY,

    -- Livre
    titre_livre TEXT,
    auteurs_livre TEXT,        -- ‚ùå "Tolkien;Lewis;Rowling"
    isbn TEXT,
    annee_publication INTEGER,
    genres TEXT,               -- ‚ùå "Fantasy;Aventure"

    -- √âditeur
    nom_editeur TEXT,
    ville_editeur TEXT,
    pays_editeur TEXT,

    -- Exemplaire
    numero_exemplaire TEXT,
    etat TEXT,                 -- 'neuf', 'bon', 'us√©', 'endommag√©'
    localisation TEXT,         -- 'A1-2-3' (all√©e-√©tag√®re-niveau)

    -- Emprunt
    emprunteur_nom TEXT,
    emprunteur_email TEXT,
    emprunteur_telephone TEXT,
    date_emprunt TEXT,
    date_retour_prevue TEXT,
    date_retour_reel TEXT,

    -- Biblioth√©caire
    bibliothecaire_nom TEXT,
    bibliothecaire_service TEXT  -- ‚ùå D√©pendance transitive
);

-- Donn√©es d'exemple probl√©matiques
INSERT INTO bibliotheque_denormalisee VALUES
    (1, 'Le Seigneur des Anneaux', 'J.R.R. Tolkien', '978-0261103573', 1954,
     'Fantasy;Aventure;√âpique', 'Flammarion', 'Paris', 'France',
     'EX001', 'bon', 'A1-2-3', 'Jean Dupont', 'jean@email.com', '0123456789',
     '2024-01-15', '2024-02-15', NULL, 'Marie Martin', 'Accueil'),
    (2, 'Harry Potter tome 1', 'J.K. Rowling', '978-2070584628', 1997,
     'Fantasy;Jeunesse', 'Gallimard', 'Paris', 'France',
     'EX002', 'neuf', 'A2-1-4', 'Sophie Leroy', 'sophie@email.com', '0987654321',
     '2024-01-20', '2024-02-20', '2024-02-18', 'Marie Martin', 'Accueil');
```

### üîÑ Solution √©tape par √©tape

```sql
-- === √âTAPE 1 : ANALYSE ET IDENTIFICATION DES ENTIT√âS ===

-- Entit√©s identifi√©es :
-- 1. Livres (titre, ISBN, ann√©e)
-- 2. Auteurs (nom, informations)
-- 3. √âditeurs (nom, ville, pays)
-- 4. Genres (nom)
-- 5. Exemplaires (num√©ro, √©tat, localisation)
-- 6. Emprunteurs (nom, email, t√©l√©phone)
-- 7. Biblioth√©caires (nom, service)
-- 8. Emprunts (dates, associations)

-- Relations identifi√©es :
-- - Livre ‚Üî Auteur (many-to-many)
-- - Livre ‚Üî Genre (many-to-many)
-- - Livre ‚Üí √âditeur (many-to-one)
-- - Exemplaire ‚Üí Livre (many-to-one)
-- - Emprunt ‚Üí Exemplaire (one-to-one ou one-to-many selon r√®gles)
-- - Emprunt ‚Üí Emprunteur (many-to-one)
-- - Emprunt ‚Üí Biblioth√©caire (many-to-one)

-- === √âTAPE 2 : SCH√âMA NORMALIS√â 3NF ===

-- Services des biblioth√©caires (entit√© s√©par√©e pour 3NF)
CREATE TABLE services (
    id INTEGER PRIMARY KEY,
    nom TEXT UNIQUE NOT NULL,
    responsable TEXT,
    localisation TEXT
);

-- Biblioth√©caires
CREATE TABLE bibliothecaires (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    email TEXT UNIQUE,
    service_id INTEGER,
    FOREIGN KEY (service_id) REFERENCES services(id)
);

-- √âditeurs
CREATE TABLE editeurs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    ville TEXT,
    pays TEXT DEFAULT 'France'
);

-- Auteurs
CREATE TABLE auteurs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    prenom TEXT,
    date_naissance TEXT,
    nationalite TEXT
);

-- Genres
CREATE TABLE genres (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT UNIQUE NOT NULL,
    description TEXT
);

-- Livres
CREATE TABLE livres (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    titre TEXT NOT NULL,
    isbn TEXT UNIQUE,
    annee_publication INTEGER,
    nombre_pages INTEGER,
    editeur_id INTEGER,
    FOREIGN KEY (editeur_id) REFERENCES editeurs(id)
);

-- Relations many-to-many : Livres ‚Üî Auteurs
CREATE TABLE livres_auteurs (
    livre_id INTEGER,
    auteur_id INTEGER,
    role TEXT DEFAULT 'auteur',  -- 'auteur', 'co-auteur', 'traducteur'
    PRIMARY KEY (livre_id, auteur_id),
    FOREIGN KEY (livre_id) REFERENCES livres(id) ON DELETE CASCADE,
    FOREIGN KEY (auteur_id) REFERENCES auteurs(id)
);

-- Relations many-to-many : Livres ‚Üî Genres
CREATE TABLE livres_genres (
    livre_id INTEGER,
    genre_id INTEGER,
    PRIMARY KEY (livre_id, genre_id),
    FOREIGN KEY (livre_id) REFERENCES livres(id) ON DELETE CASCADE,
    FOREIGN KEY (genre_id) REFERENCES genres(id)
);

-- Exemplaires (instances physiques des livres)
CREATE TABLE exemplaires (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    numero TEXT UNIQUE NOT NULL,
    livre_id INTEGER NOT NULL,
    etat TEXT CHECK (etat IN ('neuf', 'bon', 'us√©', 'endommag√©', 'perdu')),
    localisation TEXT,  -- 'A1-2-3'
    date_acquisition TEXT DEFAULT (date('now')),
    FOREIGN KEY (livre_id) REFERENCES livres(id)
);

-- Emprunteurs
CREATE TABLE emprunteurs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nom TEXT NOT NULL,
    prenom TEXT,
    email TEXT UNIQUE,
    telephone TEXT,
    adresse TEXT,
    date_inscription TEXT DEFAULT (date('now')),
    actif INTEGER DEFAULT 1
);

-- Emprunts
CREATE TABLE emprunts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    exemplaire_id INTEGER NOT NULL,
    emprunteur_id INTEGER NOT NULL,
    bibliothecaire_id INTEGER,
    date_emprunt TEXT DEFAULT (date('now')),
    date_retour_prevue TEXT NOT NULL,
    date_retour_reel TEXT,
    commentaires TEXT,
    FOREIGN KEY (exemplaire_id) REFERENCES exemplaires(id),
    FOREIGN KEY (emprunteur_id) REFERENCES emprunteurs(id),
    FOREIGN KEY (bibliothecaire_id) REFERENCES bibliothecaires(id)
);

-- === √âTAPE 3 : INSERTION DES DONN√âES NORMALIS√âES ===

-- Services
INSERT INTO services (nom, responsable, localisation) VALUES
    ('Accueil', 'Chef de service', 'Entr√©e principale'),
    ('Jeunesse', 'Responsable jeunesse', 'Aile droite'),
    ('Recherche', 'Documentaliste', '√âtage 2');

-- Biblioth√©caires
INSERT INTO bibliothecaires (nom, email, service_id) VALUES
    ('Marie Martin', 'marie.martin@biblio.fr', 1),
    ('Pierre Dubois', 'pierre.dubois@biblio.fr', 2),
    ('Claire Leroy', 'claire.leroy@biblio.fr', 3);

-- √âditeurs
INSERT INTO editeurs (nom, ville, pays) VALUES
    ('Flammarion', 'Paris', 'France'),
    ('Gallimard', 'Paris', 'France'),
    ('Le Seuil', 'Paris', 'France');

-- Auteurs
INSERT INTO auteurs (nom, prenom, nationalite) VALUES
    ('Tolkien', 'J.R.R.', 'Britannique'),
    ('Rowling', 'J.K.', 'Britannique'),
    ('Hugo', 'Victor', 'Fran√ßaise');

-- Genres
INSERT INTO genres (nom, description) VALUES
    ('Fantasy', 'Litt√©rature fantastique'),
    ('Aventure', 'Romans d''aventure'),
    ('Jeunesse', 'Litt√©rature pour jeunes'),
    ('Classique', 'Grands classiques de la litt√©rature');

-- Livres
INSERT INTO livres (titre, isbn, annee_publication, editeur_id) VALUES
    ('Le Seigneur des Anneaux', '978-0261103573', 1954, 1),
    ('Harry Potter √† l''√©cole des sorciers', '978-2070584628', 1997, 2),
    ('Les Mis√©rables', '978-2070409228', 1862, 2);

-- Relations livres-auteurs
INSERT INTO livres_auteurs (livre_id, auteur_id) VALUES
    (1, 1),  -- Tolkien ‚Üí LOTR
    (2, 2),  -- Rowling ‚Üí HP
    (3, 3);  -- Hugo ‚Üí Mis√©rables

-- Relations livres-genres
INSERT INTO livres_genres (livre_id, genre_id) VALUES
    (1, 1), (1, 2),  -- LOTR : Fantasy + Aventure
    (2, 1), (2, 3),  -- HP : Fantasy + Jeunesse
    (3, 4);          -- Mis√©rables : Classique

-- Exemplaires
INSERT INTO exemplaires (numero, livre_id, etat, localisation) VALUES
    ('EX001', 1, 'bon', 'A1-2-3'),
    ('EX002', 2, 'neuf', 'A2-1-4'),
    ('EX003', 3, 'us√©', 'B1-3-2');

-- Emprunteurs
INSERT INTO emprunteurs (nom, prenom, email, telephone) VALUES
    ('Dupont', 'Jean', 'jean@email.com', '0123456789'),
    ('Leroy', 'Sophie', 'sophie@email.com', '0987654321');

-- Emprunts
INSERT INTO emprunts (exemplaire_id, emprunteur_id, bibliothecaire_id, date_emprunt, date_retour_prevue, date_retour_reel) VALUES
    (1, 1, 1, '2024-01-15', '2024-02-15', NULL),  -- En cours
    (2, 2, 1, '2024-01-20', '2024-02-20', '2024-02-18');  -- Rendu
```

### üîç Validation du sch√©ma normalis√©

```sql
-- === TESTS DE VALIDATION ===

-- 1. V√©rification 1NF : Pas de valeurs multiples
SELECT 'V√©rification 1NF - Valeurs atomiques' as test;
-- Toutes les colonnes contiennent des valeurs atomiques ‚úÖ

-- 2. V√©rification 2NF : Pas de d√©pendances partielles
SELECT 'V√©rification 2NF - D√©pendances fonctionnelles compl√®tes' as test;
-- Tables avec cl√©s compos√©es : livres_auteurs, livres_genres
-- Pas d'attributs d√©pendant partiellement des cl√©s ‚úÖ

-- 3. V√©rification 3NF : Pas de d√©pendances transitives
SELECT 'V√©rification 3NF - Pas de d√©pendances transitives' as test;
-- Services s√©par√©s des biblioth√©caires ‚úÖ

-- 4. Tests fonctionnels
-- Livres avec leurs auteurs et genres
SELECT
    l.titre,
    GROUP_CONCAT(DISTINCT a.nom || ' ' || a.prenom) as auteurs,
    GROUP_CONCAT(DISTINCT g.nom) as genres,
    e.nom as editeur
FROM livres l
LEFT JOIN livres_auteurs la ON l.id = la.livre_id
LEFT JOIN auteurs a ON la.auteur_id = a.id
LEFT JOIN livres_genres lg ON l.id = lg.livre_id
LEFT JOIN genres g ON lg.genre_id = g.id
LEFT JOIN editeurs e ON l.editeur_id = e.id
GROUP BY l.id, l.titre, e.nom;

-- Emprunts en cours avec toutes les informations
SELECT
    l.titre,
    ex.numero,
    emp.nom || ' ' || emp.prenom as emprunteur,
    empr.date_emprunt,
    empr.date_retour_prevue,
    CASE
        WHEN date('now') > empr.date_retour_prevue THEN 'En retard'
        ELSE 'Dans les temps'
    END as statut
FROM emprunts empr
JOIN exemplaires ex ON empr.exemplaire_id = ex.id
JOIN livres l ON ex.livre_id = l.id
JOIN emprunteurs emp ON empr.emprunteur_id = emp.id
WHERE empr.date_retour_reel IS NULL;

-- Statistiques par genre
SELECT
    g.nom as genre,
    COUNT(DISTINCT l.id) as nb_livres,
    COUNT(DISTINCT ex.id) as nb_exemplaires,
    COUNT(DISTINCT empr.id) as nb_emprunts_total
FROM genres g
LEFT JOIN livres_genres lg ON g.id = lg.genre_id
LEFT JOIN livres l ON lg.livre_id = l.id
LEFT JOIN exemplaires ex ON l.id = ex.livre_id
LEFT JOIN emprunts empr ON ex.id = empr.exemplaire_id
GROUP BY g.id, g.nom
ORDER BY nb_livres DESC;
```

### üéØ Avantages obtenus par la normalisation

```sql
-- === D√âMONSTRATION DES AVANTAGES ===

-- 1. Coh√©rence garantie
-- Changer l'email d'un emprunteur
UPDATE emprunteurs SET email = 'jean.nouveau@email.com' WHERE id = 1;
-- ‚úÖ Un seul UPDATE, tous les emprunts restent coh√©rents

-- 2. Pas de redondance
-- Ajouter un nouvel exemplaire du Seigneur des Anneaux
INSERT INTO exemplaires (numero, livre_id, etat, localisation)
VALUES ('EX004', 1, 'neuf', 'A1-2-4');
-- ‚úÖ Pas besoin de dupliquer les infos du livre

-- 3. Flexibilit√©
-- Ajouter un co-auteur √† un livre
INSERT INTO livres_auteurs (livre_id, auteur_id, role)
VALUES (1, 3, 'traducteur');
-- ‚úÖ Facilement extensible

-- 4. Int√©grit√© r√©f√©rentielle
-- Tentative de suppression d'un livre avec exemplaires
-- DELETE FROM livres WHERE id = 1;
-- ‚úÖ Prot√©g√© par les contraintes FK

-- 5. Requ√™tes riches
-- Top des auteurs les plus emprunt√©s
SELECT
    a.nom || ' ' || a.prenom as auteur,
    COUNT(DISTINCT empr.id) as nb_emprunts,
    COUNT(DISTINCT l.id) as nb_livres_catalogue
FROM auteurs a
JOIN livres_auteurs la ON a.id = la.auteur_id
JOIN livres l ON la.livre_id = l.id
JOIN exemplaires ex ON l.id = ex.livre_id
JOIN emprunts empr ON ex.id = empr.exemplaire_id
GROUP BY a.id, a.nom, a.prenom
ORDER BY nb_emprunts DESC;
```

## Conclusion et perspectives

### üéâ R√©capitulatif des acquis

**Vous ma√Ætrisez maintenant :**
- ‚úÖ **1NF** : √âlimination des valeurs multiples et atomicit√©
- ‚úÖ **2NF** : Suppression des d√©pendances partielles sur cl√©s compos√©es
- ‚úÖ **3NF** : √âlimination des d√©pendances transitives
- ‚úÖ **Processus** : M√©thodologie compl√®te de normalisation
- ‚úÖ **Validation** : Techniques de v√©rification et tests
- ‚úÖ **Patterns** : Solutions courantes et bonnes pratiques SQLite

### üöÄ B√©n√©fices concrets

**Pour vos projets :**
- üîí **Int√©grit√©** : Donn√©es coh√©rentes et fiables
- ‚ö° **Maintenabilit√©** : Modifications simples et s√ªres
- üìà **√âvolutivit√©** : Structure extensible facilement
- üéØ **Performance** : Requ√™tes optimis√©es et index efficaces
- üõ°Ô∏è **Robustesse** : Protection contre les anomalies

### üí° Points cl√©s √† retenir

1. **Normalisation = organisation logique**, pas complification
2. **Chaque forme normale r√©sout des probl√®mes sp√©cifiques**
3. **3NF est g√©n√©ralement suffisant** pour la plupart des applications
4. **SQLite supporte parfaitement** la normalisation avanc√©e
5. **Validation et tests** sont essentiels apr√®s normalisation

---

**üí° Dans le prochain chapitre**, nous explorerons les relations entre tables et les jointures complexes, en nous appuyant sur nos structures normalis√©es pour cr√©er des liens robustes et performants.

**üéØ Vous savez maintenant** concevoir des bases de donn√©es SQLite propres, coh√©rentes et √©volutives gr√¢ce √† la normalisation !

‚è≠Ô∏è
