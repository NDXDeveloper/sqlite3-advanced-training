üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.3 Analyse des plans d'ex√©cution avec EXPLAIN QUERY PLAN

## Introduction √† EXPLAIN QUERY PLAN

`EXPLAIN QUERY PLAN` est votre meilleur ami pour optimiser SQLite ! C'est comme avoir une radiographie de vos requ√™tes : cela vous montre exactement ce que fait SQLite pour r√©cup√©rer vos donn√©es.

### Pourquoi c'est important ?

Imaginez que vous demandez √† quelqu'un de trouver un livre dans une biblioth√®que :
- **M√©thode lente :** "Je vais regarder livre par livre dans toute la biblioth√®que"
- **M√©thode rapide :** "Je vais directement au bon rayon gr√¢ce au catalogue"

`EXPLAIN QUERY PLAN` vous dit quelle m√©thode SQLite utilise pour votre requ√™te !

## Syntaxe et utilisation de base

### Format simple

```sql
EXPLAIN QUERY PLAN
SELECT colonne FROM table WHERE condition;
```

### Premier exemple concret

```sql
-- Cr√©ons une table d'exemple
CREATE TABLE employes (
    id INTEGER PRIMARY KEY,
    nom TEXT NOT NULL,
    age INTEGER,
    departement TEXT,
    salaire REAL
);

-- Ins√©rons quelques donn√©es
INSERT INTO employes VALUES
(1, 'Alice', 28, 'IT', 50000),
(2, 'Bob', 35, 'RH', 45000),
(3, 'Charlie', 42, 'Finance', 60000),
(4, 'Diana', 29, 'IT', 52000),
(5, 'Eve', 38, 'Marketing', 48000);

-- Analysons cette requ√™te
EXPLAIN QUERY PLAN
SELECT nom, salaire FROM employes WHERE departement = 'IT';
```

**R√©sultat typique :**
```
SCAN employes
```

**Traduction :** SQLite va regarder chaque ligne de la table `employes` une par une.

## Comprendre les r√©sultats d'EXPLAIN QUERY PLAN

### Structure de base du r√©sultat

Les r√©sultats s'affichent sous cette forme :
```
|--SCAN employes
```

Le pr√©fixe `|--` indique le niveau de l'op√©ration dans le plan d'ex√©cution.

### Vocabulaire essentiel

| Terme | Signification | Performance |
|-------|---------------|-------------|
| **SCAN** | Lecture compl√®te de la table | üêå Lent sur grandes tables |
| **SEARCH** | Utilisation d'un index | üöÄ Rapide |
| **USING INDEX** | Pr√©cise quel index est utilis√© | ‚úÖ Tr√®s bon signe |
| **USING PRIMARY KEY** | Utilise la cl√© primaire | ‚≠ê Optimal |
| **TEMP B-TREE** | Structure temporaire cr√©√©e | ‚ö†Ô∏è Co√ªteux en m√©moire |

## Exemples d√©taill√©s avec interpr√©tations

### Exemple 1 : Recherche simple sans index

```sql
EXPLAIN QUERY PLAN
SELECT * FROM employes WHERE age > 30;
```

**R√©sultat :**
```
SCAN employes
```

**Interpr√©tation :**
- SQLite lit **chaque ligne** de la table
- V√©rifie si `age > 30` pour chaque employ√©
- ‚ö†Ô∏è **Probl√®me :** Lent sur une grande table !

**Solution :**
```sql
-- Cr√©er un index sur la colonne age
CREATE INDEX idx_age ON employes(age);

-- M√™me requ√™te maintenant
EXPLAIN QUERY PLAN
SELECT * FROM employes WHERE age > 30;
```

**Nouveau r√©sultat :**
```
SEARCH employes USING INDEX idx_age (age>?)
```

**Interpr√©tation am√©lior√©e :**
- SQLite utilise l'index pour aller directement aux bonnes valeurs
- üöÄ **Beaucoup plus rapide !**

### Exemple 2 : Recherche par cl√© primaire

```sql
EXPLAIN QUERY PLAN
SELECT nom FROM employes WHERE id = 3;
```

**R√©sultat :**
```
SEARCH employes USING INTEGER PRIMARY KEY (rowid=?)
```

**Interpr√©tation :**
- Utilise la cl√© primaire (optimal !)
- Acc√®s direct √† la ligne ‚Üí tr√®s rapide
- ‚≠ê **Parfait !**

### Exemple 3 : Tri avec ORDER BY

```sql
EXPLAIN QUERY PLAN
SELECT nom, salaire FROM employes ORDER BY salaire DESC;
```

**R√©sultat sans index :**
```
SCAN employes
USE TEMP B-TREE FOR ORDER BY
```

**Interpr√©tation :**
1. SQLite lit toute la table (`SCAN`)
2. Cr√©e une structure temporaire pour trier (`TEMP B-TREE`)
3. ‚ö†Ô∏è **Double travail = lent !**

**Avec index sur salaire :**
```sql
CREATE INDEX idx_salaire ON employes(salaire DESC);

EXPLAIN QUERY PLAN
SELECT nom, salaire FROM employes ORDER BY salaire DESC;
```

**Nouveau r√©sultat :**
```
SCAN employes USING INDEX idx_salaire
```

**Interpr√©tation am√©lior√©e :**
- Les donn√©es sont d√©j√† tri√©es dans l'index
- Plus besoin de structure temporaire
- üöÄ **Plus rapide et moins de m√©moire !**

## Cas complexes avec jointures

### Exemple avec JOIN

```sql
-- Cr√©ons une deuxi√®me table
CREATE TABLE departements (
    nom TEXT PRIMARY KEY,
    budget INTEGER,
    manager TEXT
);

INSERT INTO departements VALUES
('IT', 100000, 'Alice'),
('RH', 50000, 'Bob'),
('Finance', 75000, 'Charlie'),
('Marketing', 60000, 'Eve');

-- Requ√™te avec jointure
EXPLAIN QUERY PLAN
SELECT e.nom, e.salaire, d.budget
FROM employes e
JOIN departements d ON e.departement = d.nom;
```

**R√©sultat :**
```
SCAN e
SEARCH d USING PRIMARY KEY (nom=?)
```

**Interpr√©tation :**
1. SQLite lit chaque employ√© (`SCAN e`)
2. Pour chaque employ√©, cherche le d√©partement correspondant en utilisant la cl√© primaire (`SEARCH d`)
3. ‚úÖ **Efficace** gr√¢ce √† la cl√© primaire sur `departements.nom`

### Jointure probl√©matique

```sql
-- Ajoutons une table sans cl√© appropri√©e
CREATE TABLE projets (
    id INTEGER PRIMARY KEY,
    nom_projet TEXT,
    responsable TEXT,  -- Pas de cl√© √©trang√®re !
    budget INTEGER
);

EXPLAIN QUERY PLAN
SELECT e.nom, p.nom_projet
FROM employes e
JOIN projets p ON e.nom = p.responsable;
```

**R√©sultat probl√©matique :**
```
SCAN e
SCAN p
```

**Interpr√©tation :**
- SQLite doit scanner les deux tables compl√®tement
- ‚ö†Ô∏è **Tr√®s lent !** (produit cart√©sien puis filtrage)

**Solution :**
```sql
-- Cr√©er un index sur la colonne de jointure
CREATE INDEX idx_responsable ON projets(responsable);

-- Maintenant le plan est meilleur :
-- SCAN e
-- SEARCH p USING INDEX idx_responsable (responsable=?)
```

## Requ√™tes avec sous-requ√™tes

### Sous-requ√™te simple

```sql
EXPLAIN QUERY PLAN
SELECT nom FROM employes
WHERE departement IN (
    SELECT nom FROM departements WHERE budget > 60000
);
```

**R√©sultat :**
```
SCAN employes
LIST SUBQUERY 1
  SCAN departements
```

**Interpr√©tation :**
1. SQLite ex√©cute d'abord la sous-requ√™te (`LIST SUBQUERY 1`)
2. Puis utilise les r√©sultats pour filtrer les employ√©s
3. ‚úÖ **Approche efficace** car la sous-requ√™te ne s'ex√©cute qu'une fois

### Sous-requ√™te corr√©l√©e (attention !)

```sql
EXPLAIN QUERY PLAN
SELECT nom FROM employes e1
WHERE salaire > (
    SELECT AVG(salaire) FROM employes e2
    WHERE e2.departement = e1.departement
);
```

**R√©sultat :**
```
SCAN e1
CORRELATED SCALAR SUBQUERY 1
  SCAN e2
```

**Interpr√©tation :**
- ‚ö†Ô∏è **Probl√®me :** La sous-requ√™te s'ex√©cute pour chaque ligne de e1 !
- Si 1000 employ√©s ‚Üí 1000 ex√©cutions de la sous-requ√™te
- **Tr√®s lent !**

## Techniques d'optimisation bas√©es sur les plans

### 1. Identifier les SCAN probl√©matiques

**R√®gle :** Un `SCAN` sur une table > 1000 lignes est souvent un probl√®me.

```sql
-- ‚ùå Probl√©matique
EXPLAIN QUERY PLAN
SELECT * FROM employes WHERE departement = 'IT' AND age > 25;
-- R√©sultat : SCAN employes

-- ‚úÖ Solution
CREATE INDEX idx_dept_age ON employes(departement, age);
-- Nouveau r√©sultat : SEARCH employes USING INDEX idx_dept_age
```

### 2. √âliminer les TEMP B-TREE

```sql
-- ‚ùå Probl√©matique
EXPLAIN QUERY PLAN
SELECT * FROM employes ORDER BY departement, salaire DESC;
-- R√©sultat : SCAN employes + USE TEMP B-TREE FOR ORDER BY

-- ‚úÖ Solution
CREATE INDEX idx_dept_sal ON employes(departement, salaire DESC);
-- Nouveau r√©sultat : SCAN employes USING INDEX idx_dept_sal
```

### 3. Optimiser les jointures

```sql
-- ‚ùå Jointure lente
EXPLAIN QUERY PLAN
SELECT e.nom, d.budget
FROM employes e, departements d
WHERE e.departement = d.nom AND d.budget > 50000;
-- R√©sultat : SCAN e + SCAN d (produit cart√©sien !)

-- ‚úÖ Meilleure syntaxe
EXPLAIN QUERY PLAN
SELECT e.nom, d.budget
FROM employes e
JOIN departements d ON e.departement = d.nom
WHERE d.budget > 50000;
-- R√©sultat : SCAN e + SEARCH d USING PRIMARY KEY
```

## Mode d'affichage d√©taill√©

### Activer plus de d√©tails

```sql
-- Voir plus d'informations sur les co√ªts
.eqp on

-- Ou pour une requ√™te sp√©cifique
EXPLAIN QUERY PLAN
SELECT * FROM employes WHERE age BETWEEN 25 AND 35;
```

### Informations de co√ªt

Parfois, SQLite affiche des estimations de co√ªt :
```
SEARCH employes USING INDEX idx_age (age>? AND age<?) (~10 rows)
```

**Interpr√©tation :**
- `~10 rows` : SQLite estime r√©cup√©rer environ 10 lignes
- Plus le nombre est petit, plus l'op√©ration est s√©lective (bien !)

## Cas pratiques d'optimisation

### Cas 1 : Rapport de ventes lent

```sql
-- Table de ventes avec beaucoup de donn√©es
CREATE TABLE ventes (
    id INTEGER PRIMARY KEY,
    vendeur TEXT,
    produit TEXT,
    montant REAL,
    date_vente DATE,
    region TEXT
);

-- Requ√™te probl√©matique
EXPLAIN QUERY PLAN
SELECT vendeur, SUM(montant) as total
FROM ventes
WHERE date_vente >= '2024-01-01'
  AND region = 'Nord'
GROUP BY vendeur
ORDER BY total DESC;
```

**R√©sultat avant optimisation :**
```
SCAN ventes
USE TEMP B-TREE FOR GROUP BY
USE TEMP B-TREE FOR ORDER BY
```

**Probl√®mes identifi√©s :**
1. `SCAN` complet de la table
2. Deux structures temporaires (GROUP BY et ORDER BY)

**Solution d'optimisation :**
```sql
-- Index composite pour le WHERE
CREATE INDEX idx_date_region ON ventes(date_vente, region);

-- Index pour optimiser le GROUP BY
CREATE INDEX idx_vendeur ON ventes(vendeur);
```

**R√©sultat apr√®s optimisation :**
```
SEARCH ventes USING INDEX idx_date_region (date_vente>? AND region=?)
USE TEMP B-TREE FOR GROUP BY
USE TEMP B-TREE FOR ORDER BY
```

**Am√©lioration :** Le SCAN devient SEARCH ‚Üí beaucoup plus rapide !

### Cas 2 : Pagination inefficace

```sql
-- Pagination classique probl√©matique
EXPLAIN QUERY PLAN
SELECT * FROM employes
ORDER BY nom
LIMIT 20 OFFSET 1000;
```

**R√©sultat :**
```
SCAN employes
USE TEMP B-TREE FOR ORDER BY
```

**Probl√®me :** SQLite trie TOUS les employ√©s pour ensuite ignorer les 1000 premiers !

**Solution :**
```sql
-- Index sur la colonne de tri
CREATE INDEX idx_nom ON employes(nom);

-- Nouveau plan
EXPLAIN QUERY PLAN
SELECT * FROM employes
ORDER BY nom
LIMIT 20 OFFSET 1000;
```

**R√©sultat optimis√© :**
```
SEARCH employes USING INDEX idx_nom
```

**Am√©lioration :** Plus de tri temporaire, acc√®s direct aux bonnes lignes !

## Outils complementaires pour l'analyse

### 1. Mesurer le temps d'ex√©cution

```sql
-- Activer le timer
.timer on

-- Comparer avant/apr√®s optimisation
SELECT COUNT(*) FROM employes WHERE departement = 'IT';
-- Temps affich√© automatiquement
```

### 2. Analyser l'utilisation m√©moire

```sql
-- Statistiques d√©taill√©es
.stats on

-- Votre requ√™te
SELECT * FROM employes ORDER BY salaire DESC;

-- Affiche l'usage m√©moire et les pages lues
```

### 3. Forcer la mise √† jour des statistiques

```sql
-- SQLite utilise des statistiques pour optimiser
-- Les mettre √† jour apr√®s de gros changements :
ANALYZE employes;

-- Ou toute la base :
ANALYZE;
```

## Guide de diagnostic rapide

### Checklist pour analyser un plan

1. **Cherchez les mots-cl√©s probl√©matiques :**
   - `SCAN` sur grande table ‚Üí cr√©er un index
   - `TEMP B-TREE` r√©p√©t√©s ‚Üí optimiser ORDER BY/GROUP BY
   - `SCAN` dans les deux tables d'un JOIN ‚Üí ajouter index sur cl√© de jointure

2. **V√©rifiez la s√©lectivit√© :**
   - `(~10 rows)` = tr√®s s√©lectif = bon
   - `(~10000 rows)` = peu s√©lectif = probl√©matique

3. **Analysez l'ordre des op√©rations :**
   - Les filtres (`WHERE`) doivent √™tre appliqu√©s t√¥t
   - Les tris (`ORDER BY`) devraient utiliser des index

### Exemples de plans optimaux

```sql
-- ‚úÖ Excellent plan
SEARCH employes USING INDEX idx_dept_age (departement=? AND age>?)

-- ‚úÖ Bon plan avec jointure
SCAN e USING INDEX idx_dept
SEARCH d USING PRIMARY KEY (nom=?)

-- ‚úÖ Optimal pour tri
SCAN employes USING INDEX idx_salaire_desc
```

### Exemples de plans probl√©matiques

```sql
-- ‚ùå Probl√©matique
SCAN employes (sur table > 10000 lignes)

-- ‚ùå Tr√®s probl√©matique
SCAN table1
SCAN table2 (jointure sans index)

-- ‚ùå Gourmand en m√©moire
USE TEMP B-TREE FOR ORDER BY
USE TEMP B-TREE FOR GROUP BY
```

## Exercices pratiques

### Exercice 1 : Diagnostic d'une application e-commerce

```sql
-- Tables d'un site e-commerce
CREATE TABLE clients (
    id INTEGER PRIMARY KEY,
    nom TEXT,
    email TEXT UNIQUE,
    ville TEXT,
    date_inscription DATE
);

CREATE TABLE commandes (
    id INTEGER PRIMARY KEY,
    client_id INTEGER,
    total REAL,
    date_commande DATE,
    statut TEXT
);

-- Requ√™tes √† analyser et optimiser :

-- 1. Recherche de client
EXPLAIN QUERY PLAN
SELECT * FROM clients WHERE email = 'alice@email.com';

-- 2. Commandes d'un client
EXPLAIN QUERY PLAN
SELECT * FROM commandes WHERE client_id = 123 ORDER BY date_commande DESC;

-- 3. Rapport mensuel
EXPLAIN QUERY PLAN
SELECT c.nom, COUNT(*) as nb_commandes, SUM(co.total) as total
FROM clients c
JOIN commandes co ON c.id = co.client_id
WHERE co.date_commande >= '2024-01-01'
GROUP BY c.id, c.nom
ORDER BY total DESC;
```

**Mission :** Analysez chaque plan et proposez les index n√©cessaires.

### Exercice 2 : Optimisation progressive

1. **Cr√©ez une table de test avec beaucoup de donn√©es**
2. **Testez cette requ√™te complexe :**
```sql
SELECT vendeur,
       COUNT(*) as nb_ventes,
       AVG(montant) as moyenne,
       SUM(montant) as total
FROM ventes v
WHERE date_vente BETWEEN '2024-01-01' AND '2024-12-31'
  AND region IN ('Nord', 'Sud')
  AND montant > 100
GROUP BY vendeur
HAVING COUNT(*) > 5
ORDER BY total DESC
LIMIT 10;
```

3. **Analysez le plan avec `EXPLAIN QUERY PLAN`**
4. **Cr√©ez les index un par un et observez l'√©volution du plan**
5. **Mesurez l'am√©lioration des performances avec `.timer on`**

## R√©sum√© et bonnes pratiques

### Points cl√©s √† retenir

‚úÖ **EXPLAIN QUERY PLAN** vous montre exactement ce que fait SQLite
‚úÖ **SCAN** = lent sur grandes tables ‚Üí cr√©er des index
‚úÖ **SEARCH USING INDEX** = rapide ‚Üí bon signe !
‚úÖ **TEMP B-TREE** = utilisation m√©moire ‚Üí optimiser ORDER BY/GROUP BY
‚úÖ **Mesurer avant/apr√®s** avec `.timer on` pour valider les am√©liorations

### Workflow d'optimisation

1. **Identifier** les requ√™tes lentes de votre application
2. **Analyser** avec `EXPLAIN QUERY PLAN`
3. **Chercher** les `SCAN` et `TEMP B-TREE` probl√©matiques
4. **Cr√©er** les index appropri√©s
5. **V√©rifier** l'am√©lioration du plan
6. **Mesurer** le gain de performance r√©el

### R√®gles d'or

- **Un SCAN sur > 1000 lignes** ‚Üí probablement besoin d'un index
- **Plusieurs TEMP B-TREE** ‚Üí optimiser les tris et groupements
- **SCAN dans les deux tables d'un JOIN** ‚Üí ajouter index sur cl√© de jointure
- **Toujours mesurer l'impact** ‚Üí certaines optimisations peuvent √™tre contre-productives

`EXPLAIN QUERY PLAN` transforme l'optimisation SQLite d'un art myst√©rieux en une science pr√©cise ! Dans la section suivante, nous verrons comment appliquer concr√®tement toutes ces connaissances pour optimiser les requ√™tes les plus lentes de vos applications.

‚è≠Ô∏è
